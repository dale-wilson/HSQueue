<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>HSQueue by dale-wilson</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>HSQueue</h1>
          <h2>A Queue for High Speed message passing between threads, processes, or other components.</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/dale-wilson/HSQueue/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/dale-wilson/HSQueue/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/dale-wilson/HSQueue" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h1>

<blockquote>
<p>IMPORTANT: This is under construction.  It works but it is not ready for critical applications, yet.</p>
</blockquote>

<p>A High Speed Queue (HSQ) is a mechanism for message passing between components of a system.  It is most often used to pass messages between two or more threads in the same process, but it can also be used for intra-process communication by putting the HSQueue in shared memory. </p>

<h2>
<a id="clients" class="anchor" href="#clients" aria-hidden="true"><span class="octicon octicon-link"></span></a>Clients</h2>

<p>HSQueue clients can be either a Publisher or a Consumer.
• Producers create and publish data into the HSQueue.<br>
• Consumers accept and process data from the HSQueue.
Each HSQueue instance supports multiple Producers, but only a single Consumer.</p>

<h1>
<a id="client-api" class="anchor" href="#client-api" aria-hidden="true"><span class="octicon octicon-link"></span></a>Client API</h1>

<p>The HSQueue API consists of the public interfaces of four primary classes:   Message, Connection, Consumer, and Producer.  Two additional classes, CreationParameters and ConsumerWaitStrategy are used to initialize the HSQueue.</p>

<h2>
<a id="start-with-a-connection" class="anchor" href="#start-with-a-connection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Start with a Connection</h2>

<p>A Connection provides access to a HSQueue.  A Connection may be used to create an initialize a new HSQueue, or it may be used to attach to an existing HSQueue (presumably in shared memory.)  Once the HSQueue is created or located, the Connection can be used to initialize Producer and Consumer clients.</p>

<h2>
<a id="step-by-step" class="anchor" href="#step-by-step" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step-by-step:</h2>

<p>• Construct a Connection object.  No construction arguments are required.
• If the Connection will be used to create a new HSQueue:
o   Construct a ConsumerWaitStrategy which specifies how Consumers wait for messages
o   Construct a CreationParameters object containing the ConsumerWaitStrategy and other configuration information such as the number of messages that can be queued, the maximum size of a message, etc.
 Note that for performance reasons HSQueue does not do any dynamic memory allocation.  Thus it must be configured properly at initialization time to achieve the best performance.
o   Call Connection::createLocal() or Connection::createOrOpenShared().
• If the Connection will be used only to locate an existing HSQueue in shared memory
o   Call Connection::openExistingShared();
This Connection object may now be used to create a Consumer and one or more Producers.</p>

<h2>
<a id="to-add-a-consumer" class="anchor" href="#to-add-a-consumer" aria-hidden="true"><span class="octicon octicon-link"></span></a>To Add a Consumer</h2>

<p>• Construct a Consumer passing the Connection as an argument.
• Construct a Message with no construction arguments.
• Use the Connection::allocate(Message) to initialize the Message.
o   Most consumers will need only one Message which should be created at the time the consumer is being initialized.  This Message will be reused for each message received.
• Accept a message from the HSQueue by calling either:
 Consumer::tryGetNext(Message &amp;), or
 Consumer::getNext(Message &amp;)
o   If a message is available, these methods are identical. 
o   If no message is available 
 tryGetNext() returns immediately with a false result, whereas 
 getNext() will wait for the message to return using the ConsumerWaitStrategy that was specified when the HSQueue was created.
• getNext() may also return false if the HSQueue is shutting down.
• Use methods on the Message to access the information from the message.
• When the consumer no longer needs the contents of a message, it can simply reuse the message for the next tryGetNext() or getNext() call.</p>

<h3>
<a id="to-add-one-or-more-producers" class="anchor" href="#to-add-one-or-more-producers" aria-hidden="true"><span class="octicon octicon-link"></span></a>To Add One or More Producers</h3>

<p>• Construct a Producer passing the Connection as the contruction argument.
• Construct a Message with no construction arguments.
o   Most producers will need only one Message object which should be created at the time the producer is being initialized.  This Message object will be reused for each message being sent.
• Call Connection::allocate(Message &amp;) to initialize the message.
• Populate the Message with the information to be passed to the consumer.
o   Several methods on the Message make this easy and type-safe.  These methods will be described later.
• Publish the message by calling the Producer::publish(Message &amp;); method.
o   When the publish() method returns, the Message will be empty, ready to be populated with the next message.</p>

<h2>
<a id="api-notes" class="anchor" href="#api-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>API Notes</h2>

<p>• The producer may take as long as it needs to construct a message directly in the Message.  If there are other producers using the same HSQueue they will be unaffected by the time it takes a particular producer to prepare its message for publication. (See the example below.)
• Clients lose access to information in a message once they use the Message object in a publish() or getNext() call.  In particular pointers to the data contained in a message are invalided when the Message object is reused.
• When a client is ready to exit, it simply lets the Message and Producer or Consumer objects go out of scope (or otherwise be deleted.)  This cleans up the resources used by the client.
o   The Connection will still be ready to service additional clients.
• The Connection object MUST live longer than all clients and Messages that use it.<br>
o   This requirement is not currently enforced.</p>
        </section>

        <footer>
          HSQueue is maintained by <a href="https://github.com/dale-wilson">dale-wilson</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>