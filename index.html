<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>HighQueue by dale-wilson</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>HighQueue</h1>
          <h2>A Queue for High Speed message passing between threads, processes, or other components.</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/dale-wilson/HighQueue/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/dale-wilson/HighQueue/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/dale-wilson/HighQueue" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h1>

<blockquote>
<p>IMPORTANT: This is under construction.  It works but it is not ready for critical applications, yet.</p>
</blockquote>

<pre>
  The HighQueue Haiku

  To send messages
  So quickly you must use a
  Good algorithm.
</pre>


<p>A High Speed Queue (HighQueue) is a mechanism for message passing between components of a system.  
It is most often used to pass messages between two or more threads in the same process, but it can also be used for intra-process communication by putting the HighQueue in shared memory. </p>

<h2>
<a id="clients" class="anchor" href="#clients" aria-hidden="true"><span class="octicon octicon-link"></span></a>Clients</h2>

HighQueue clients can be either a Publisher or a Consumer.
<ul>
<li>Producers create and publish data into the HighQueue. </li>   
<li>Consumers accept and process data from the HighQueue. </li>
</ul>
 
<p>Each HighQueue instance supports multiple Producers, but only a single Consumer.</p>
<h1>
<a id="clientAPI" class="anchor" href="#clientAPI" aria-hidden="true"><span class="octicon octicon-link"></span></a>
Client API
</h1>

<p>The HighQueue API consists of the public interfaces of four primary classes:   
Message, Connection, Consumer, and Producer.  
Two additional classes, CreationParameters and ConsumerWaitStrategy are used to initialize the HighQueue.
</p>
<h2>Start with a Connection</h2>
<p>A Connection provides access to a HighQueue.  A Connection may be used to create an initialize a new HighQueue, or it may be used to attach to an existing HighQueue (presumably in shared memory.)  Once the HighQueue is created or located, the Connection can be used to initialize Producer and Consumer clients.
</p>

<h3>Step-by-step:</h3>
<ul>
	<li>Construct a Connection object.  No construction arguments are required.</li>
	<li>If the Connection will be used to create a new HighQueue:
		<ul>
			<li>Construct a ConsumerWaitStrategy which specifies how Consumers wait for messages</li>
			<li>Construct a CreationParameters object containing the ConsumerWaitStrategy and other configuration information such as the number of messages that can be queued, the maximum size of a message, etc.</li>
			<ul>
				<li>Note that for performance reasons HighQueue does not do any dynamic memory allocation.  Thus it must be configured properly at initialization time to achieve the best performance.</li>
			</ul>
			<li>Call Connection::createLocal() or Connection::createOrOpenShared().</li>
		</ul>
	</li>
	<li>  *	If the Connection will be used only to locate an existing HighQueue in shared memory
		<ul>
			<li>    *	Call Connection::openExistingShared();</li>
		</ul>
	</li>
</ul>

<p>This Connection object may now be used to create a Consumer and one or more Producers.</p>

<h2>To Add a Consumer</h2>
<ul>
	<li>Construct a Consumer passing the Connection as an argument.</li>
	<li>Construct a Message with no construction arguments.</li>
	<li>Use the Connection::allocate(Message) to initialize the Message.
		<ul>
			<li>Most consumers will need only one Message which should be created at the time the consumer is being initialized.  This Message will be reused for each message received.</li>
		</ul>
	</li>
	<li>Accept a message from the HighQueue by calling either:
		<ul>
			<li>Consumer::tryGetNext(Message &), or </li>
			<li>Consumer::getNext(Message &)</li>
		</ul>
	</li>
	<li>If a message is available, these methods are identical. </li>
	<li>If no message is available 
		<ul>
			<li>tryGetNext() returns immediately with a false result, whereas </li>
			<li>getNext() will wait for the message to return using the ConsumerWaitStrategy that was specified when the HighQueue was created.
				<ul>
					<li>getNext() may also return false if the HighQueue is shutting down.</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>Use methods on the Message to access the information from the message.</li>
	<li>When the consumer no longer needs the contents of a message, it can simply reuse the message for the next tryGetNext() or getNext() call. </li>
</ul>

<h2>To Add One or More Producers</h2>
<ul>
	<li>Construct a Producer passing the Connection as the contruction argument.</li>
	<li>Construct a Message with no construction arguments.
		<ul>
			<li>Most producers will need only one Message object which should be created at the time the producer is being initialized.  This Message object will be reused for each message being sent.</li>
		</ul>
	</li>
	<li>Call Connection::allocate(Message &) to initialize the message.</li>
	<li>Populate the Message with the information to be passed to the consumer.
		<ul>
			<li>Several methods on the Message make this easy and type-safe.</li>
		</ul>
	</li>
	<li>Publish the message by calling the Producer::publish(Message &); method.
		<ul>
			<li>When the publish() method returns, the Message will be empty, ready to be populated with the next message.</li>
		</ul>
	</li>

<h2>API Notes</h2>
<ul>
	<li>The producer may take as long as it needs to construct a message directly in the Message.  If there are other producers using the same HighQueue they will be unaffected by the time it takes a particular producer to prepare its message for publication.</li>
	<li>Clients lose access to information in a message once they use the Message object in a publish() or getNext() call.  In particular pointers to the data contained in a message are invalided when the Message object is reused.</li>
	<li>When a client is ready to exit, it simply lets the Message and Producer or Consumer objects go out of scope (or otherwise be deleted.)  This cleans up the resources used by the client.</li>
	<li>The Connection will still be ready to service additional clients.<li>
	<li>The Connection object MUST live longer than all clients and Messages that use it.  
		<ul>
			<li>This requirement is not currently enforced.</li>
		</ul>
	</li>
</ul>

<h1>Populating a Message Before Publishing it</h1>
<p>To be done</p>

<h1>Access Data From a Received Message.</h1>
<p>To be done</p>

        <footer>
          HighQueue is maintained by <a href="https://github.com/dale-wilson">dale-wilson</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>