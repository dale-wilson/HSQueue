{"name":"HSQueue","tagline":"A Queue for High Speed message passing between threads, processes, or other components.","body":"# Introduction\r\n\r\n> IMPORTANT: This is under construction.  It works but it is not ready for critical applications, yet.\r\n \r\nA High Speed Queue (HSQ) is a mechanism for message passing between components of a system.  It is most often used to pass messages between two or more threads in the same process, but it can also be used for intra-process communication by putting the HSQueue in shared memory. \r\n##Clients\r\nHSQueue clients can be either a Publisher or a Consumer.\r\n•\tProducers create and publish data into the HSQueue.   \r\n•\tConsumers accept and process data from the HSQueue.\r\nEach HSQueue instance supports multiple Producers, but only a single Consumer.\r\n\r\n#Client API\r\nThe HSQueue API consists of the public interfaces of four primary classes:   Message, Connection, Consumer, and Producer.  Two additional classes, CreationParameters and ConsumerWaitStrategy are used to initialize the HSQueue.\r\n##Start with a Connection\r\nA Connection provides access to a HSQueue.  A Connection may be used to create an initialize a new HSQueue, or it may be used to attach to an existing HSQueue (presumably in shared memory.)  Once the HSQueue is created or located, the Connection can be used to initialize Producer and Consumer clients.\r\n\r\n##Step-by-step:\r\n•\tConstruct a Connection object.  No construction arguments are required.\r\n•\tIf the Connection will be used to create a new HSQueue:\r\no\tConstruct a ConsumerWaitStrategy which specifies how Consumers wait for messages\r\no\tConstruct a CreationParameters object containing the ConsumerWaitStrategy and other configuration information such as the number of messages that can be queued, the maximum size of a message, etc.\r\n\tNote that for performance reasons HSQueue does not do any dynamic memory allocation.  Thus it must be configured properly at initialization time to achieve the best performance.\r\no\tCall Connection::createLocal() or Connection::createOrOpenShared().\r\n•\tIf the Connection will be used only to locate an existing HSQueue in shared memory\r\no\tCall Connection::openExistingShared();\r\nThis Connection object may now be used to create a Consumer and one or more Producers.\r\n##To Add a Consumer\r\n•\tConstruct a Consumer passing the Connection as an argument.\r\n•\tConstruct a Message with no construction arguments.\r\n•\tUse the Connection::allocate(Message) to initialize the Message.\r\no\tMost consumers will need only one Message which should be created at the time the consumer is being initialized.  This Message will be reused for each message received.\r\n•\tAccept a message from the HSQueue by calling either:\r\n\tConsumer::tryGetNext(Message &), or\r\n\tConsumer::getNext(Message &)\r\no\tIf a message is available, these methods are identical. \r\no\tIf no message is available \r\n\ttryGetNext() returns immediately with a false result, whereas \r\n\tgetNext() will wait for the message to return using the ConsumerWaitStrategy that was specified when the HSQueue was created.\r\n•\tgetNext() may also return false if the HSQueue is shutting down.\r\n•\tUse methods on the Message to access the information from the message.\r\n•\tWhen the consumer no longer needs the contents of a message, it can simply reuse the message for the next tryGetNext() or getNext() call.\r\n###To Add One or More Producers\r\n•\tConstruct a Producer passing the Connection as the contruction argument.\r\n•\tConstruct a Message with no construction arguments.\r\no\tMost producers will need only one Message object which should be created at the time the producer is being initialized.  This Message object will be reused for each message being sent.\r\n•\tCall Connection::allocate(Message &) to initialize the message.\r\n•\tPopulate the Message with the information to be passed to the consumer.\r\no\tSeveral methods on the Message make this easy and type-safe.  These methods will be described later.\r\n•\tPublish the message by calling the Producer::publish(Message &); method.\r\no\tWhen the publish() method returns, the Message will be empty, ready to be populated with the next message.\r\n##API Notes\r\n•\tThe producer may take as long as it needs to construct a message directly in the Message.  If there are other producers using the same HSQueue they will be unaffected by the time it takes a particular producer to prepare its message for publication. (See the example below.)\r\n•\tClients lose access to information in a message once they use the Message object in a publish() or getNext() call.  In particular pointers to the data contained in a message are invalided when the Message object is reused.\r\n•\tWhen a client is ready to exit, it simply lets the Message and Producer or Consumer objects go out of scope (or otherwise be deleted.)  This cleans up the resources used by the client.\r\no\tThe Connection will still be ready to service additional clients.\r\n•\tThe Connection object MUST live longer than all clients and Messages that use it.  \r\no\tThis requirement is not currently enforced.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}