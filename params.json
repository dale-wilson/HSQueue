{"name":"HighQueue","tagline":"A Queue for High Performance message passing between threads, processes, or other components.","body":"# Introduction\r\n\r\n> IMPORTANT: This is beta. Please test it, but remember it is not ready for critical applications, yet.\r\n \r\nA High Performance Queue (HighQueue) is a mechanism for message passing between components of a system.  It is most often used to pass messages between two or more threads in the same process, but it can also be used for intra-process communication by putting the HighQueue in shared memory. \r\n\r\n```\r\n  The HighQueue Haiku\r\n\r\n  To send messages\r\n  So quickly you must use a\r\n  Good algorithm.\r\n```\r\n\r\n##Clients\r\nHighQueue clients can be either a Publisher or a Consumer.\r\n* Producers create and publish data into the HighQueue.   \r\n* Consumers accept and process data from the HighQueue.\r\nEach HighQueue instance supports multiple Producers, but only a single Consumer.\r\n\r\n##How fast is it?\r\nAbsolute performance numbers are notoriously difficult to measure accurately. The results vary widely from machine to machine.\r\n\r\nThat being said, tests on an Intel(R) Core(TM) i7-4790 CPU @3.60GHz [8 cores] with one producer and one consumer\r\nshow sustained throughput is around 16.6 million messages/second.  This translates to around 60 nanoseconds per message delivery.  \r\n\r\nIn addition to message delivery time, these measurements include the time to acquire the memory space needed to compose the next message, the time to compose the simple 88 byte message, and the time for the consumer to access the entire message after receiving it.  Many benchmarks omit these factors even though they can easily cut the delivery rate in half.\r\n\r\nHighQueue can sustain this delivery rate up to 6 producers and one consumer on this machine.  Beyond that the threads start\r\ncompeting with the operating system (Win7) and with each other for the available cores and throughput starts to drop.\r\n[With 8 producers + 1 consumer + Windows a message is delivered to the consumer thread every 145 nanoseconds.]\r\n\r\nAs a point of comparison 60 nsec per message with an 88 byte message translates to around 11 Ghz.  Thus messages arriving over a 10 Ghz network can be easily distribute to processing threads much faster than they arrive through the network -- especially taking into account the network overhead that means a 10 Ghz network will never reach its theoretical maximum delivery speed.  \r\n\r\nOf course measuring this performance in Ghz can be misleading because most of the time is incurred on a per-message basis rather than per-byte or per-bit, so increasing the message size increases the GHz measurement almost linearly.  With an 800 byte message the measured bit throughput rate is 55 Ghz.\r\n\r\nYou can generate equivalent numbers for your machine by running the MultithreadPerformanceTest which is included in the HQPerformance executable.\r\n\r\n<em>Your Mileage Will Vary!</em>\r\n\r\n##HighQueue depends on\r\n\r\n  * A modern C++ compiler that implements the C++11 standard.\r\n    * VisualStudio 12 (2013) works.\r\n    * gcc 4.7.2 works.\r\n  * OCI's Make Project Creator (MPC) V4.1 or later. (http://www.ociweb.com/products/mpc)\r\n    * MPC is used to create make files for gcc or Visual Studio [tm] solution and project files.\r\n  * Boost Test (any recent version) (http://www.boost.org/)\r\n    * Boost test is used for functional and performance testing. \r\n\r\nNeither MPC nor Boost is needed at runtime. \r\n\r\n##Licensing\r\nHighQueue is distributed with a very friendly, non-viral license.  You are required to include the HighQueue license including the appropriate disclaimers with any product that incorporates HighQueue.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}