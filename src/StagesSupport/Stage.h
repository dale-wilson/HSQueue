// Copyright (c) 2015 Object Computing, Inc.
// All rights reserved.
// See the file license.txt for licensing information.
#pragma once

#include "StageFwd.h"
#include <StagesSupport/Stage_Export.h>
#include <StagesSupport/BuildResourcesFwd.h>
#include <StagesSupport/ConfigurationFwd.h>
#include "HighQueue/ConnectionFwd.h"
#include <HighQueue/MemoryPoolFwd.h>
#include "HighQueue/MessageFwd.h"

#include <Common/Log.h>

namespace HighQueue
{
    namespace Stages
    {
        /// @brief Base class for Stages
        /// 
        /// Stage life cycle:
        /// 0: Register.
        ///    A Stage class should register itself with the StageFactory by creating a static instance of 
        ///    StageFactory::Registrar<stageclass>.
        ///
        /// 1: Construct
        ///    A Stage should have a null constructor so it can be created with a StageFactory.
        ///
        /// 2: Configure
        ///   2a: Read configuration parameters.
        ///       The stage gets configuration parameters(if any) from configurationNode. 
        ///   2b: Configure resources
        ///       Sets parameters for shared resources in BulderResource.  Shared resources include a
        ///       memory pool, an AsioService, etc.
        ///
        /// 3 Attachment
        ///   3a: Attach Destination(s)
        ///       Zero or more destinations may be attached. Messages generated by the stage should be sent to
        ///       these destinations.
        ///   3b: Attach Resources 
        ///       The resources configured during [2: Configure] will have been created.  
        ///       The Stage can capture the ones it needs.
        ///
        /// 4: Validate
        ///    Each Stage checks to be sure all required parameters are configured and make sense, and that
        ///    all necessary attachments are available.  If errors are detected, the Stage should throw an 
        ///    exception.
        ///    If all Stages pass validation then the system will go live.
        ///
        /// 5: Start
        ///    The system is going live.  The Stage should Open files, sockets, place initial ASIO requests,etc.
        ///    After this call the stage may generate messages for following stages an may receive messages from
        ///    previous stages.
        ///
        ///    Start should not fail due to missing configuration or attachments, because problems should have
        ///    been identified during Validate; however Start may still fail due to runtime issues (remote host 
        ///    denied connection, can't open file, etc.)  If it fails, the Stage will throw an exception and the
        ///    system will immediately shut down again.
        ///
        /// 6: Handle
        ///    Process an incoming message.
        ///           
        /// 7: Pause
        ///    Temporarily stop sending to destination (optional)
        ///
        /// 8: Resume
        ///    Continue after a pause
        ///
        /// 9: Stop
        ///   Begin the shut-down process.  Stop producing output messages for following stages.
        ///   Note the stage may still receive input messages from previous stages for a brief period of time.
        ///
        /// 10: Finish
        ///   No Messages from previous stages will arive.  The stage should join threads, close files, etc. as 
        ///   necessary to allow a clean shut down of the system.
        ///
        /// 11: Destruct
        ///     There should be nothign left to do at this point, but check anyway if it matters.

        class Stages_Export Stage: public std::enable_shared_from_this<Stage>
        {
        public:
            static const std::string keyName;
            /// @brief Construct 
            /// Lifecycle 1: Constuct
            Stage();

            /// @brief destruct
            /// Lifecycle 11: Destruct
            virtual ~Stage();

            /// @brief Configure 
            /// Lifecycle 2: Configure
            virtual bool configure(const ConfigurationNode & configuration);
            
            virtual bool configureParameter(const std::string & key, const ConfigurationNode & configuration);

            virtual void configureResources(BuildResources & resources);

            /// @brief Configure
            /// Lifecycle 2a: Give it a name
            void setName(const std::string & name);

            const std::string & getName()const;

            /// @brief Attach primary destination
            /// Lifecycle 3: Attach
            virtual void attachDestination(const StagePtr & destination);
            
            /// @brief Attach named destination
            /// Lifecycle 3: Attach
            virtual void attachDestination(const std::string & name, const StagePtr & destination);

            /// @brief Attach resources
            virtual void attachResources(BuildResources & resources);

            /// @brief Validate configuration and attachments
            /// Lifecycle 4: Validate
            virtual void validate();
            
            /// @brief Go Live
            /// Lifecycle 5: Start
            virtual void start();

            /// @brief Handle a message.
            /// Lifecycle 6: Handle
            /// Default behavior is to throw a runtime_error exception.
            /// Override if this stage accepts incoming messages.
            /// @param message is the one to handle.
            /// @returns false if we should stop now.
            virtual void handle(Message & message);

            /// @brief Temporary stop sending to destination
            /// @lifecycle 7: Pause
            virtual void pause();

            /// @brief Resume after pause
            /// Lifecycle 8: Resume
            virtual void resume();

            /// @brief Stop
            /// Lifecycle 9: Stop
            virtual void stop();

            /// @brief Final cleanup
            /// Lifecycle 10: Finish
            virtual void finish();

            bool isStopping()const;
            bool isPaused() const;
        protected:
            void mustHaveDestination();
            void mustHaveDestination(const std::string & name);
            void mustNotHaveDestination();
            size_t destinationIndex(const std::string & name);
            void send(Message & message);
            void send(const std::string & name, Message & message);
            void send(size_t index, Message & message);

        protected:
            bool paused_;
            bool stopping_;
            std::string name_;
            StagePtr primaryDestination_;
            typedef std::pair<std::string,  StagePtr> NamedDestination;
            std::vector<NamedDestination> destinations_;
        };

        inline
        bool Stage::isStopping()const 
        { 
            return stopping_;
        }

        inline
        bool Stage::isPaused() const
        { 
            return paused_;
        }

        inline
        void Stage::send(Message & message)
        {
            primaryDestination_->handle(message);
            message.setEmpty();
        }

        inline
        void Stage::send(const std::string & name, Message & message)
        {
            for(auto & named : destinations_)
            {
                auto & destName = named.first;
                if(destName /*named.first */ == name)
                {
                    named.second->handle(message);
                    return;
                }
            }
            LogWarning("No destination named " << name << " was attached.");
        }

        inline
        void Stage::send(size_t index, Message & message)
        {
            destinations_[index].second->handle(message);
        }
   }
}